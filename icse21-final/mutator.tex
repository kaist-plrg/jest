\subsection{Program Mutator}
$\tool$ increases the semantics coverage of the program pool by mutating programs
using five mutation methods randomly.

\subsubsection{Random Mutation}
The first na\"ive method is to randomly select a statement, a
declaration, or an expression in a given program and to replace it
with a randomly selected one from a set of syntax trees generated by
the non-recursive synthesizer.
For example, it may mutate a program \code{var x = 1 + 2;} by replacing
its random expression \code{1} with a random expression \code{true} producing
\code{var x = true + 2;}.


\subsubsection{Nearest Syntax Tree Mutation}
The second method targets uncovered branches in abstract algorithms.
When only one branch is covered by a program, it finds the nearest
syntax tree in the program that reaches the branch in the algorithm, and
replaces the nearest syntax tree with a random syntax tree derivable
from the same syntax production.  For example, consider the following JavaScript program:
\begin{lstlisting}[style=myJSstyle]
                var x = "" + (1 == 2);
\end{lstlisting}
While it covers the false branch of the first step of
\textbf{Abstract Equality Comparison} in Figure~\ref{fig:example}(a),
assume that no program in the program pool can cover its true branch.
Then, the mutator targets this branch, finds its nearest syntax tree
\code{1 == 2} in the program, and replaces it with a random syntax tree.


\subsubsection{String Substitutions}
We collect all string literals used in conditions of the algorithms in ES11
and use them for random expression substitutions.
Because most string literals in the specification represent corner cases
such as \code{-0}, \code{Infinity}, and \code{NaN}, they are necessary for mutation
to increase the semantics coverage.  For example, the semantics of the
[[DefineOwnProperty]] internal method of array exotic objects depends
on whether the value of its parameter \code{P} is \code{"length"} or not.


\subsubsection{Object Substitutions}
We also collect string literals and symbols used as arguments of object
property access algorithms in ES11, randomly generate objects using them,
and replace random expressions with the generated objects.
Because some abstract algorithms in the specification access object properties
using \textbf{HasProperty}, \textbf{GetMethod}, \textbf{Get}, and
\textbf{OrdinaryGetOwnProperty}, 
objects with such properties are necessary for mutation to achieve high coverage.  
Thus, the mutator mutates a randomly selected expression in a program with a
randomly generated object that has properties whose keys are from
collected string literals and symbols.


\subsubsection{Statement Insertion}
To synthesize more complex programs, the mutator inserts random
statements at the end of randomly selected blocks like
top-level code and function bodies.  We generate random
statements using the non-recursive synthesizer with pre-defined
special statements.  The special statements are control diverters, which
have high chances of changing execution paths, such as function calls,
\code{return}, \code{break}, and \code{throw} statements.  The mutator
selects special statements with a higher probability than the statements
randomly synthesized by the non-recursive synthesizer.
