\section{Introduction}\label{sec:intro}

In Peter O'Hearn's keynote speech in ICSE 2020, he quoted the following from
Mark Zuckerberg's Letter to Investors~\cite{mzletter}:
\begin{quote}
  The Hacker Way is an approach to building that involves continuous improvement
  and iteration.  Hackers believe that somethings can always be better, and that
  nothing is ever complete.
\end{quote}
Indeed, modern programming follows the continuous integration (CI) and
continuous deployment (CD) approach~\cite{cicd} rather than the traditional waterfall model.
Instead of a sequential model that divides software development into
several phases, each of which takes time, CI/CD amounts to a cycle of
quick software development, deployment, and back to development with
feedback. Even the development of programming languages uses the CI/CD approach.

Consider JavaScript, one of the most widely used programming languages
for client-side and server-side programming~\cite{nodejs} and
embedded systems~\cite{moddable,espruino,tessel2}.  Various JavaScript
engines provide diverse extensions to adapt to fast-changing user demands.  At
the same time, ECMAScript, the official specification that describes the syntax and
semantics of JavaScript, is annually updated since ECMAScript 6 (ES6,
2015)~\cite{es6} to support new features in response to user demands.
Such updates in both the specification and implementations in tandem make it
difficult for them to be in sync.

Another example is Solidity~\cite{officialSolDoc}, the standard smart contract programming language
for the Ethereum blockchain.  The Solidity language specification is continuously
updated, and the Solidity compiler is also frequently released.  According to
Hwang and Ryu~\cite{solidity-gap}, the average number of days between consecutive
releases from Solidity 0.1.2 to 0.5.7 is 27.  In most cases, the Solidity compiler reflects
updates in the specification, but even the specification is revised
according to the semantics implemented in the compiler.  As in JavaScript,
bidirectional effects in the specification and the implementation make
it hard to guarantee their correspondence.

In this approach, both the specification and the implementation may contain bugs,
and guaranteeing their correctness is a challenging task.
The conventional approach to build a programming language is uni-directional from
a language specification to its implementation.  The specification is believed to
be correct and the conformance of an implementation to the specification is
checked by dynamic testing.  Unlike in the conventional approach, in the modern CI/CD
approach, the specification may not be the oracle, because both the
specification and the implementation can co-evolve.

In this paper, we propose a novel \textit{$N$+1-version differential testing}, which
enables testing of co-evolving specifications and their implementations.  The
differential testing~\cite{diff-test} is a testing technique, which executes $N$
implementations of a specification concurrently for each input, and detects a
problem when the outputs are in disagreement.  In addition to $N$
implementations, our approach tests the specification as well using a
mechanized specification.  Recently, several approaches to extract syntax and
semantics directly from language specifications are presented\cite{jiset,
extract-x86, extract-arm}.  We utilize them to bridge the gap between
specifications and their implementations through conformance tests generated
from mechanized specifications.  The $N$+1-version differential testing consists of
three steps: 1) to automatically synthesize programs guided by the syntax and
semantics from a given language specification, 2) to generate conformance tests
by injecting assertions to the synthesized programs to check their final program
states, 3) to detect bugs in the specification and implementations
via executing the conformance tests on multiple implementations, and 4) to
localize bugs on the specification using statistical information.

Given a language specification and $N$ existing real-world
implementations of the specification, we
automatically generate a conformance test suite from the specification with
assertions in each test code to make sure that the result of running the code
conforms to the specification semantics.  Then, we run the test suite for $N$
implementations of the specification.  Because generated tests strictly comply
with the specification, they reflect specification errors as well, if any.  When
one of the implementations fails in running a test, the
implementation may have a bug, as in the differential testing.  When
most of the implementations fail in running a test, it is highly likely that
the specification has a bug.  By automatically generating a rich set of test
code from the specification and running them with implementations of the
specification, we can find and localize bugs either in the specification written
in a natural language or in its implementations.

To show the practicality of the proposed approach, we present $\tool$, which
is a \underline{J}avaScript \underline{E}ngines and
\underline{S}pecification \underline{T}ester using $N$+1-version differential testing.
We implement $\tool$ by extending $\jiset$~\cite{jiset}, a JavaScript
IR-based semantics extraction toolchain, to utilize the syntax and semantics
automatically extracted from ECMAScript.  Using the extracted syntax,
our tool automatically synthesizes initial seed programs and expands the program
pool by mutating specific target programs guided by semantics coverage.  Then,
the tool generates conformance tests by injecting assertions to synthesized
programs.  Finally, $\tool$ detects and localizes bugs using execution
results of the tests on $N$ JavaScript engines.  We evaluate our tool with four
JavaScript engines (Google V8\cite{v8}, GraalJS\cite{graaljs}, QuickJS\cite{qjs},
and Moddable XS\cite{xs}) that support all modern JavaScript language
features and the latest ECMAScript (ES11, 2020).

The main contributions of this paper include the following:
\begin{itemize}
  \item Present \textit{$N$+1-version differential testing}, a novel solution to the new
    problem of co-evolving language specifications and their implementations.
  \item Implement $N$+1-version differential testing for JavaScript engines and
    ECMAScript as a tool called $\tool$. It is the first tool that automatically generates conformance
    tests for JavaScript engines from ECMAScript.  While the coverage
    of Test262, the official conformance tests, is 91.61\% for statements
    and 82.91\% for branches, the coverage of the conformance tests generated by the tool
    is 87.70\% for statements and 78.30\% for branches.
  \item Evaluate $\tool$ with four modern JavaScript engines and the latest
    ECMAScript, ES11.  Using the generated conformance test
    suite, the tool found and localized 44 engine bugs in four different
    engines and 27 specification bugs in ES11.
\end{itemize}
