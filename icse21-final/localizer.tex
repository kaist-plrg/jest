\subsection{Bug Localizer}

The bug detection and localization phase uses the execution results of
given conformance tests on multiple JavaScript engines.
If a small number of engines fail in running a specific conformance test,
the engines may have bugs causing the test failure.
If most engines fail for a test, the test may be incorrect,
which implies a bug in the specification.

When we have a set of failed test cases that may contain bugs of an engine or a
specification, we classify the test cases using their failure
messages and give ranks between possible buggy program elements to localize the bug.
We use Spectrum Based Fault Localization (SBFL)~\cite{sbfl-survey},
which is a ranking technique based on likelihood of being faulty for each
program element.  We use the following formula called $ER1_b$,
which is one of the best SBFL formulae theoretically analyzed by Xie et al.~\cite{er1b}:
\[
  {n_{\mbox{\emph{\scriptsize ef}}}} -
  {
    {n_{\mbox{\emph{\scriptsize ep}}}}
    \over
    {n_{\mbox{\emph{\scriptsize ep}}} + n_{\mbox{\emph{\scriptsize np}}} + 1}
  }
\]
where $n_{ef}$, $n_{ep}$ , $n_{nf}$, and $n_{np}$ represent the number of test
cases; subscripts ${}_e$ and ${}_n$ respectively denote whether a test case touches a
relevant program element or not, and subscripts ${}_f$ and ${}_p$
respectively denote whether the test case is failed or passed.

We use abstract algorithms of ECMAScript as program elements used for SBFL.
To improve the localization accuracy, we use method-level aggregation~\cite{fluccs}.
It first calculates SBFL scores for algorithm steps and aggregates
them up to algorithm-level using the highest score among those from steps of each algorithm.
