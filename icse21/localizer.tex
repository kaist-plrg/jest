\subsection{Bug Localizer}

The bug detection and localization phase uses the execution results of
given conformance tests on multiple JavaScript engines.
If a small number of engines fail in running a specific conformance test,
the engines may have bugs causing the test failure.
If most engines fail for a test, the test may be incorrect,
which implies a bug in the specification.

When we have an engine or a specification that may contain a bug and
a set of failed test cases, we classify the test cases using their failure
messages and give ranks between possible buggy program elements to localize the bug.
We use Spectrum Based Fault Localization (SBFL)~\cite{sbfl-survey},
which is a ranking technique based on likelihood of being faulty for each
program element.  We use the following formula called $ER1_b$,
which is one of the best SBFL formulae theoretically analyzed by Xie et al.~\cite{er1b}:
\[
  {n_{\mbox{\emph{\scriptsize ef}}}} -
  {
    {n_{\mbox{\emph{\scriptsize ep}}}}
    \over
    {n_{\mbox{\emph{\scriptsize ep}}} + n_{\mbox{\emph{\scriptsize np}}} + 1}
  }
\]
where $n_{ef}$, $n_{ep}$ , $n_{nf}$, and $n_{np}$ represent the number of test
cases; subscripts ${}_e$ and ${}_n$ respectively denote whether a test case touches a
relevant program element or not, and subscripts ${}_f$ and ${}_p$
respectively denote whether the test case is failed or passed.

We use abstract algorithms of ECMAScript as program elements used for SBFL.
To improve the localization accuracy, we use method-level aggregation~\cite{fluccs}.
It first calculates SBFL scores for algorithm steps and aggregates
them up to algorithm-level using the highest score among those from steps of each algorithm.
