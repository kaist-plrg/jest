\subsection{Assertion Injector}

After generating JavaScript programs, \mytextsf{Assertion Injector} injects
assertions to them using their final states as specified in ECMAScript.
It first obtains the final state of a given program from the
mechanized specification and injects seven kinds of assertions in the beginning of the program.
To check the final state after executing all asynchronous jobs,
we enclose assertions with \code{setTimeout} to wait 100 ms when a
program uses asynchronous features such as \code{Promise} and \code{async}:
\begin{lstlisting}[style=myJSstyle]
  ... /* a given program */
  setTimeout(() => { ... /* assertions */ }, 100)
\end{lstlisting}


\subsubsection{Exceptions}

JavaScript supports both internal exceptions like \code{SyntaxError} and
\code{TypeError} and custom exceptions with the keyword \code{throw}.
Note that catching such exceptions using the \code{try-catch} statement
may change the program semantics.  For example, the following does not throw any exception:
\begin{lstlisting}[style=myJSstyle]
    var x; function x() {}
\end{lstlisting}
but the following:
\begin{lstlisting}[style=myJSstyle]
    try { var x; function x() {} } catch (e) {}
\end{lstlisting}
throws \code{SyntaxError} because declarations of a variable and a function
with the same name are not allowed in \code{try-catch}.

To resolve this problem, we exploit a comment in the first line of a program.
If the program throws an internal exception, we tag its name in the comment.
Otherwise, we tag \code{// Throw} for a custom exception and \code{// Normal} for
normal termination.  Using the tag in the comment, $\tool$ checks the
execution result of a program in each engine.


\subsubsection{Crashes}

The mechanized semantics of ECMAScript can crash due to unspecified cases.
For example, consider the following JavaScript program:
\begin{lstlisting}[style=myJSstyle]
    var x = 42; x++;
\end{lstlisting}
The postfix increment operator (\code{++}) increases the number value
stored in the variable \code{x}.  However, because of a typo in the
\textbf{Evaluation} algorithm for such update expressions in ES11, the
behavior of the program is not defined in ES11.  To represent this situation in
the conformance test, we tag \code{Crash} in the comment as follows:
\begin{lstlisting}[style=myJSstyle]
    // Crash
    var x = 42; x++;
\end{lstlisting}


\subsubsection{Variable Values}

We inject assertions that compare the values of variables with expected values.
To focus on variables introduced by tests, we do not
check the values of pre-defined variables like built-in objects.
For numbers, we distinguish \code{-0} from \code{+0} using division by zero because \code{-0/0} and
\code{+0/0} produce positive and negative infinity values, respectively.
%For objects, we use various assertions to check their values deeply.
The following example checks whether the value of \code{x} is \code{3}:
\begin{lstlisting}[style=myJSstyle]
    var x = 1 + 2;
    $assert.sameValue(x, 3);
\end{lstlisting}
%$

\subsubsection{Object Values}

To check the equality of object values, we keep a representative path for each object.
If the injector meets an object for the first time, it keeps the current path of the object 
as its representative path and injects assertions for the properties of the object.
Otherwise, the injector adds assertions to compare the values of the
objects with the current path and the representative path.  In
the following example:
\begin{lstlisting}[style=myJSstyle]
    var x = {}, y = {}, z = { p: x, q: y };
    $assert.sameValue(z.p, x);
    $assert.sameValue(z.q, y);
\end{lstlisting}
because the injector meets two different new objects
stored in \code{x} and \code{y}, it keeps the paths \code{x} and \code{y}.
Then, the object stored in \code{z} is also a new object but its
properties \code{z.p} and \code{z.q} store already visited objects values.
Thus, the injector inserts two assertions that check whether \code{z.p} and \code{x} have
the same object value and \code{z.q} and \code{y} as well.
To handle built-in objects, we store all the paths of built-in objects in advance.


\subsubsection{Object Properties}

Checking object properties involves checking four attributes for each property.
We implement a helper \code{\$verifyProperty} to check the attributes of each property for each object.
For example, the following code checks the attributes of the property of \code{x.p}:
\begin{lstlisting}[style=myJSstyle]
    var x = { p: 42 };
    $verifyProperty(x, "p", {
        value: 42.0,      writable: true,
        enumerable: true, configurable: true
    });
\end{lstlisting}
%$

\subsubsection{Property Keys}

Since ECMAScript 2015 (ES6), the specification defines orders between property keys in objects.
We check the order of property keys by \code{Reflect.ownKeys},
which takes an object and returns an array of the object's property keys.
We implement a helper \code{\$assert.compareArray} that takes two
arrays and compares their lengths and contents.
For example, the following program checks the property keys and their order of the object in \code{x}:
\begin{lstlisting}[style=myJSstyle]
var x = { [Symbol.match]: 0, p: 0, 3: 0, q: 0 }
$assert.compareArray(
    Reflect.ownKeys(x), ["3", "p", "q", Symbol.match]
);
\end{lstlisting}
%$

\subsubsection{Internal Methods and Slots}

While internal methods and slots of JavaScript objects are generally inaccessible by users,
the names in the following are accessible by indirect getters:
\[
\small
  \begin{array}{l|l}
    \telem{c|}{Name}   & \telem{c}{Indirect Getter}\\\hline
    \text{[[Prototype]]}  & \code{Object.getPrototypeOf(x)}\\\hline
    \text{[[Extensible]]} & \code{Object.isExtensible(x)}\\\hline
    \text{[[Call]]}       & \code{typeof f === "function"}\\\hline
    \text{[[Construct]]}  & \code{Reflect.construct(function()\{\},[],x)}
  \end{array}
\]

The internal slot [[Prototype]] represents the prototype object of an object,
which is available by a built-in function \code{Object.getPrototypeOf}.
The internal slot [[Extensible]] is also available by a built-in function \code{Object.isExtensible(x)}.
The internal methods [[Call]] and [[Construct]] represent whether a given object is
a function and a constructor, respectively.  Because the methods are not JavaScript values,
we simply check their existence using helpers \code{\$assert.callable}
and \code{\$assert.constructable}.  For [[Call]], we use the \code{typeof} operator because it returns
\code{"function"} if and only if a given value is an object with the [[Call]] method.
For [[Construct]] method, we use the \code{Reflect.construct} 
built-in function that checks the existence of the [[Construct]] methods and invokes it.
To avoid invoking [[Construct]] unintentionally, we call \code{Reflect.construct} with
a dummy function \code{function()\{\}} as its first argument and 
a given object as its third argument.  For example, the following code shows
how the injector injects assertions for internal methods and slots:
\begin{lstlisting}[style=myJSstyle]
  function f() {}
  $assert.sameValue(Object.getPrototypeOf(f),
                    Function.prototype);
  $assert.sameValue(Object.isExtensible(x), true);
  $assert.callable(f);
  $assert.constructable(f);
\end{lstlisting}
