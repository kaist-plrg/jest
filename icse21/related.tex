\section{Related Work}\label{sec:related}

Our technique is related to three research fields: differential testing,
fuzzing, and fault localization.

\textbf{Differential Testing:} Differential testing~\cite{diff-test} utilizes
multiple implementations as cross-referencing oracles to find semantics bugs.
Researchers applied this technique to various applications domain such as Java
Virtual Machine (JVM) implementations~\cite{diff-jvm}, SSL/TLS certification
validation logic~\cite{nezha,diff-ssl,diff-ssl2}, web
applications~\cite{diff-web}, and binary lifters~\cite{ir-diff-test}.
Moreover, \textsc{Nezha}~\cite{nezha} introduces a guided differential testing tool with
the concept of $\delta$-diversity to efficiently find semantics bugs.
However, they have a fundamental limitation that they cannot test specifications;
they use only cross-referencing oracles and target potential bugs in implementations.
Our $N$+1-version differential testing extends the idea of
differential testing with not only $N$ different 
implementations but also a mechanized specification to test both of them.
In addition, our approach automatically generates conformance tests directly from
the specification.

\textbf{Fuzzing:} Fuzzing is a software testing technique for detecting
security vulnerabilities by generating~\cite{imf,gen-fuzzing,csmith} or
mutating~\cite{mutate-fuzzing,mutate-fuzzing2,mutate-fuzzing3} test inputs.
For JavaScript~\cite{js-hopl} engines,
Patrice et al.~\cite{grammar-whitebox} presented white-box fuzzing using the JavaScript grammar,
Han et al.~\cite{codealchemist} presented CodeAlchemist that generates JavaScript code
snippets based on semantics-aware assembly,
Wang et al.~\cite{superion} presented Superion using Grammar-aware greybox fuzzing,
Park et al.~\cite{die} presented \textsc{Die} using aspect-preserving mutation,
and Lee et al.~\cite{montage} presented Montage using neural network language models (NNLMs).
While they focus on finding security vulnerabilities rather than
semantics bugs, our $N$+1-version differential testing
focuses on finding semantics bugs by comparing multiple
implementations with the mechanized specification,
which was automatically extracted from ECMAScript by $\jiset$.
Note that $\tool$ can also localize not only specification bugs in ECMAScript
but also bugs in JavaScript engines indirectly using the bug locations in ECMAScript.

\textbf{Fault Localization:} To localize detected bugs in ECMAScript, we used
Spectrum Based Fault Localization (SBFL)~\cite{sbfl-survey}, which is a ranking
technique based on likelihood of being faulty for each program element.
Tarantula~\cite{tarantula, tarantula2} was the first tool that supports SBFL
with a simple formula and researchers have developed many formulae~\cite{ample, zoltar,
sbfl-model, effect-sbfl} to increase the accuracy of bug localization.
Sohn and Yoo~\cite{fluccs} introduced a novel approach for fault
localization using code and change metrics via learning of SBFL formulae.
While we utilize the basic formula introduced by Tarantula, we
believe that it is possible to improve the accuracy of bug localization by
using more advanced SBFL techniques.

% SAGE~\cite{sage}
